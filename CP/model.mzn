include "globals.mzn";

/*int: restart;
int: changeVal;
*/
int: chip_width;
int: chip_max_height;
int: n_blocks;   % Number of blocks
set of int: BLOCKS = 1..n_blocks;
array[BLOCKS] of int: widths;
array[BLOCKS] of int: heights;

array[BLOCKS] of var 0..chip_width: blocks_x;
array[BLOCKS] of var 0..chip_max_height: blocks_y;

constraint max([blocks_x[i] + widths[i] | i in BLOCKS]) <= chip_width;

constraint cumulative(blocks_y, heights, widths, chip_width);
var int: chip_height = max(b in BLOCKS)(blocks_y[b] + heights[b]);
constraint chip_height<=chip_max_height;
constraint cumulative(blocks_x, widths, heights, chip_height);
% relationships among circuits
constraint diffn(blocks_x, blocks_y, widths, heights);

array[1..2*n_blocks] of var int: flat_board;

constraint forall (i in BLOCKS) ( flat_board[i] = blocks_x[i] /\ flat_board[n_blocks+i] = blocks_y[i] );
% symmetry breaking (horizontal flip, vertical flip and 180Â° rotation)
constraint lex_lesseq(flat_board, [ if i <= n_blocks 
                                    then abs(chip_width - blocks_x[i] - widths[i]) 
                                    else flat_board[i] 
                                    endif | i in 1..2*n_blocks])
        /\ lex_lesseq(flat_board, [ if i > n_blocks 
                                    then abs(chip_height - blocks_y[i-n_blocks] - heights[i-n_blocks]) 
                                    else flat_board[i]
                                    endif | i in 1..2*n_blocks])
        /\ lex_lesseq(flat_board, [ if i > n_blocks 
                                    then abs(chip_height - blocks_y[i-n_blocks] - heights[i-n_blocks]) 
                                    else abs(chip_width - blocks_x[i] - widths[i])
                                    endif | i in 1..2*n_blocks]);


/*ann: search_ann_x = if heuristic == 1 then
  int_search(blocks_x, input_order, indomain_min)
elseif heuristic == 2 then
  int_search(blocks_x, first_fail, indomain_min)
elseif heuristic == 3 then
  int_search(blocks_x, dom_w_deg, indomain_min)
elseif heuristic == 3 then
  int_search(blocks_x, smallest, indomain_min)
elseif heuristic == 4 then
  int_search(blocks_x, input_order, indomain_random)
elseif heuristic == 5 then
  int_search(blocks_x, first_fail, indomain_random)
else
  int_search(blocks_x, dom_w_deg, indomain_random)
endif;

ann: search_ann_y = if heuristic == 1 then
  int_search(blocks_y, input_order, indomain_min)
elseif heuristic == 2 then
  int_search(blocks_y, first_fail, indomain_min)
elseif heuristic == 3 then
  int_search(blocks_y, dom_w_deg, indomain_min)
elseif heuristic == 4 then
  int_search(blocks_y, input_order, indomain_random)
elseif heuristic == 5 then
  int_search(blocks_y, first_fail, indomain_random)
else
  int_search(blocks_y, dom_w_deg, indomain_random)
endif;

ann: restart_ann =
if restart == 1 then
  restart_constant(100)
elseif restart == 2 then
  restart_linear(100)
elseif restart == 3 then
  restart_geometric(1.5,100)
elseif restart == 4 then
  restart_luby(100)
else
  restart_none
endif;
*/
%solve minimize chip_height;
ann: search_ann_x = int_search(blocks_x, dom_w_deg, indomain_min);
ann: search_ann_y = int_search(blocks_y, first_fail, indomain_min);

ann: restart_ann = restart_luby(100);
solve :: search_ann_x
      :: search_ann_y
      :: restart_ann minimize chip_height;
      
output ["\(blocks_x)\n",
        "\(blocks_y)\n",
        "\(chip_height)\n",
        ];
  